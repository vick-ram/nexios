from __future__ import annotations

import inspect
from enum import Enum
from datetime import date, time, datetime, timedelta
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List, Type, Tuple, Union, Annotated, get_origin, get_args
from uuid import UUID
from decimal import Decimal
from pathlib import Path
from ipaddress import IPv4Address, IPv4Network, IPv6Address, IPv6Network

from nexios.orm._model import FieldInfo, NexiosModel

class Dialect(ABC):
    """Base class for database dialects"""

    @abstractmethod
    def get_type_mapping(
        self,
        max_digits: Optional[int] = None,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
    ) -> Dict[type, str]: ...

    @abstractmethod
    def auto_increment_keyword(self) -> str: ...

    @abstractmethod
    def quote_identifier(self, identifier: str) -> str: ...


class SQLiteDialect(Dialect):
    def get_type_mapping(
        self,
        max_digits: Optional[int] = None,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
    ) -> Dict[type, str]:
        return {
            int: "INTEGER",
            str: "TEXT",
            float: "REAL",
            bool: "INTEGER",
            bytes: "BLOB",
            datetime: "TEXT",
            date: "TEXT",
            time: "TEXT",
            timedelta: "INTEGER",
            Decimal: "NUMERIC",
            UUID: "TEXT",
            dict: "TEXT",
            list: "TEXT",
            Enum: "TEXT",
            object: "BLOB",
        }

    def auto_increment_keyword(self) -> str:
        return "AUTOINCREMENT"

    def quote_identifier(self, identifier: str) -> str:
        return f'"{identifier}"'


class PostgreSQLDialect(Dialect):
    def get_type_mapping(
        self,
        max_digits: Optional[int] = None,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
    ) -> Dict[type, str]:
        string_type = (
            f"VARCHAR({max_digits})" if max_digits and max_digits <= 255 else "TEXT"
        )
        return {
            int: "BIGINT",
            str: string_type,
            Path: "TEXT",
            float: "DOUBLE PRECISION",
            bool: "BOOLEAN",
            bytes: "BYTEA",
            datetime: "TIMESTAMP",
            date: "DATE",
            time: "TIME",
            timedelta: "INTERVAL",
            Decimal: f"NUMERIC({precision}, {scale})",
            UUID: "UUID",
            IPv4Address: "INET",
            IPv6Address: "INET",
            IPv4Network: "INET",
            IPv6Network: "INET",
            dict: "JSONB",
            list: "JSONB",
            Enum: "TEXT",
            object: "BYTEA",
        }

    def auto_increment_keyword(self) -> str:
        return "GENERATED BY DEFAULT AS IDENTITY"

    def quote_identifier(self, identifier: str) -> str:
        return f'"{identifier}"'


class MySQLDialect(Dialect):
    def get_type_mapping(
        self,
        max_digits: Optional[int] = None,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
    ) -> Dict[type, str]:
        def resolve_str() -> str:
            if max_digits:
                if max_digits <= 255:
                    return f"VARCHAR({max_digits})"
                elif max_digits <= 65535:
                    return "TEXT"
                elif max_digits <= 16777215:
                    return "MEDIUMTEXT"
                else:
                    return "LONGTEXT"
            else:
                return "'TEXT"
        string_type = resolve_str()
        
        return {
            int: "BIGINT",
            str: string_type,
            float: "DOUBLE",
            bool: "BOOLEAN",
            bytes: "BLOB",
            datetime: "DATETIME",
            date: "DATE",
            time: "TIME",
            timedelta: "BIGINT",
            Decimal: f"DECIMAL({precision}, {scale})",
            UUID: "CHAR(36)",
            IPv4Address: "VARCHAR(45)",
            IPv6Address: "VARCHAR(45)",
            IPv4Network: "VARCHAR(45)",
            IPv6Network: "VARCHAR(45)",
            dict: "JSON",
            list: "JSON",
            Enum: "VARCHAR(255)",
            object: "BLOB",
        }

    def auto_increment_keyword(self) -> str:
        return "AUTO_INCREMENT"

    def quote_identifier(self, identifier: str) -> str:
        return f"`{identifier}`"

class DDLGenerator:
    """Generate DDL statements from ORM model"""

    def __init__(self, dialect: Dialect) -> None:
        self.dialect = dialect or SQLiteDialect()
    
    def tablename(self, model_class: Type[NexiosModel]) -> str:
        tbname = model_class.__tablename__
        assert tbname is not None
        return tbname
    
    def primary_key(self, model_class: Type[NexiosModel]) -> Any:
        for field_name, field_info in model_class.model_fields.items():
            if isinstance(field_info, FieldInfo) and field_info.primary_key:
                return field_name
        return 'id'

    def create_table(self, model_class: Type[NexiosModel]) -> str:
        """Generate CREATE TABLE statements"""
        table_name = self.tablename(model_class)
        columns = self._get_column_definitions(model_class)
        constraints = self._get_table_constraints(model_class)

        column_defs = ",\n    ".join(columns + constraints)

        return f"CREATE TABLE IF NOT EXISTS {self.dialect.quote_identifier(table_name)} (\n    {column_defs}\n);"

    def delete(self, model_class: Type[NexiosModel]) -> str:
        """Delete statement
        model_class: Instance of the NexiosModel
        name: is any field value that matches the condition
        """
        from nexios.orm.query import ColumnExpression

        tablename = self.tablename(model_class)
        condition = ColumnExpression(
            model_class, self.primary_key(model_class) # type: ignore
        ) 
        sql = (
            f"DELETE FROM {self.dialect.quote_identifier(tablename)} WHERE {condition}"
        )

        return sql

    def upsert(self, model_class: Type[NexiosModel]) -> Tuple[str, tuple]:
        """Insert or update statement"""
        insert_sql, params = self._insert(model_class)
        sql = insert_sql + " " + self._update(model_class)
        return sql, params

    def drop_table(self, model_class: Type[NexiosModel]) -> str:
        """Generate DROP TABLE statement"""
        table_name = self.tablename(model_class)
        return f"DROP TABLE IF EXISTS {self.dialect.quote_identifier(table_name)};"

    def _get_param_placeholder(self) -> str:
        placeholder = ""

        if isinstance(self.dialect, PostgreSQLDialect):
            placeholder = "%s"
        elif isinstance(self.dialect, MySQLDialect):
            placeholder = "%s"
        else:
            placeholder = "?"

        return placeholder

    def _insert(self, model_class: Type[NexiosModel]) -> Tuple[str, tuple]:
        fields_to_save: Dict[str, Any] = {}
        tablename = self.tablename(model_class)
        placeholder = self._get_param_placeholder()
        fields = model_class.get_fields()

        for field_name, field_info in fields.items():
            value = getattr(model_class, field_name, None)
            if value is not None:
                fields_to_save[field_name] = value

        field_names = list(fields_to_save.keys())
        placeholders = ", ".join(len(field_names) * [placeholder])
        field_names_str = ", ".join(field_names)
        assert tablename is not None
        sql = f"INSERT INTO {self.dialect.quote_identifier(tablename)} ({field_names_str}) VALUES ({placeholders});"
        params = tuple(getattr(model_class, fname) for fname in field_names)

        return sql, params

    def _update(self, model_class: Type[NexiosModel]):
        # To be fixed: not a complete implementation
        fields = model_class.get_fields()
        update_sql = ""
        fields_to_update = []

        for field_name, field_info in fields.items():
            if not field_info.primary_key:
                fields_to_update.append(field_name)

        for field in fields_to_update:
            if isinstance(self.dialect, PostgreSQLDialect):
                update_sql = f"ON CONFLICT ({self.primary_key(model_class)}) DO UPDATE SET {field}"
            elif isinstance(self.dialect, MySQLDialect):
                update_sql = f"ON DUPLICATE KEY UPDATE {field} = VALUES({field})"
            else:
                update_sql = f"ON CONFLICT ({self.primary_key(model_class)}) DO UPDATE SET {field} = excluded.{field}"
        return update_sql

    def _get_column_definitions(self, model_class: Type[NexiosModel]) -> List[str]:
        """Generate column definitions for CREATE TABLE"""
        columns = []
        fields = model_class.get_fields()

        for field_name, column_info in fields.items():
            column_def = self._build_column_definition(
                field_name, column_info, model_class
            )
            columns.append(column_def)

        return columns

    def _build_column_definition(
        self, field_name: str, field_info: FieldInfo, model_class: Type[NexiosModel]
    ) -> str:
        """Build a single column definition"""
        parts = [self.dialect.quote_identifier(field_name)]

        field_type = self._get_field_type(model_class, field_name)
        db_type = self._map_python_type(field_type)

        parts.append(db_type)

        if field_info.primary_key:
            parts.append("PRIMARY KEY")
            if field_info.auto_increment:
                if db_type.upper() in (
                    "INTEGER",
                    "INT",
                    "BIGINT",
                    "SMALLINT",
                    "SERIAL",
                    "BIGSERIAL",
                ):
                    parts.append(self.dialect.auto_increment_keyword())
        elif not field_info.nullable:
            parts.append("NOT NULL")

        if field_info.unique and not field_info.primary_key:
            parts.append("UNIQUE")

        default_value = self._get_default_value(model_class, field_name)
        if default_value is not None:
            parts.append(f"DEFAULT {default_value}")

        return " ".join(parts)

    def _get_field_type(self, model_class: Type[NexiosModel], field_name: str) -> type:
        """Get the python type for a field"""
        annotation = model_class.__annotations__.get(field_name, str)

        while True:
            origin = get_origin(annotation)

            # Annotated[T, ...]
            if origin is Annotated:
                annotation = get_args(annotation)[0]
                continue

            # Optional / Union[T, None]
            if origin is Union:
                args = [arg for arg in get_args(annotation) if arg is not type(None)]
                annotation = args[0] if args else str
                continue

            break

        return annotation

    def _map_python_type(self, python_type: type) -> str:
        """Map python type to database type"""
        type_mapping = self.dialect.get_type_mapping()

        if python_type in type_mapping:
            return type_mapping[python_type]

        # Enum subclasses
        if inspect.isclass(python_type) and issubclass(python_type, Enum):
            return type_mapping[Enum]

        return type_mapping.get(object, "TEXT")

    def _get_default_value(
        self, model_class: Type[NexiosModel], field_name: str
    ) -> Optional[str]:
        """Get SQL default value for a field"""
        # field = model_class.__orm_config__.fields.get(field_name)
        field = model_class.get_fields().get(field_name)

        if not field:
            return None

        default = field.default

        if default is None:
            return None

        if callable(default):
            return None

        if isinstance(default, str):
            return f"'{default}'"

        if isinstance(default, Enum):
            return f"'{default.value}'"

        if isinstance(default, bool):
            return "TRUE" if default else "FALSE"

        if isinstance(default, (dict, list)):
            import json

            return f"'{json.dumps(default)}'"

        if isinstance(default, (int, float, Decimal)):
            return str(default)

        if isinstance(default, UUID):
            return f"'{default}'"

        if isinstance(default, (datetime, date, time)):
            return f"'{default.isoformat()}'"
        return f"'{str(default)}'"

    def _get_table_constraints(self, model_class: Type[NexiosModel]) -> List[str]:
        """Generate table-level constraints"""
        constraints = []

        # for i, unique_cols in enumerate(model_class.__orm_config__.unique_constraints):
        #     columns = ", ".join(
        #         self.dialect.quote_identifier(col) for col in unique_cols
        #     )
        #     constraints.append(
        #         f"CONSTRAINT uk_{model_class.__orm_config__.table_name}_{i} UNIQUE ({columns})"
        #     )
        constraints.extend(self._get_foreign_key_constraints(model_class))
        return constraints

    def _get_foreign_key_constraints(self, model_class: Type[NexiosModel]) -> List[str]:
        """Generate FOREIGN KEY constraints"""
        constraints = []
        fields = model_class.get_fields()

        for field_name, field_info in fields.items():
            if field_info.foreign_key:
                fk_parts = field_info.foreign_key.split(".")
                ref_table = fk_parts[0]
                ref_column = fk_parts[1] if len(fk_parts) > 1 else "id"

                constraint_name = (
                    f"fk_{self.tablename(model_class)}_{field_name}"
                )
                constraints.append(
                    f"CONSTRAINT {constraint_name} "
                    f"FOREIGN KEY ({self.dialect.quote_identifier(field_name)}) "
                    f"REFERENCES {self.dialect.quote_identifier(ref_table)} ({self.dialect.quote_identifier(ref_column)})"
                )
        return constraints
